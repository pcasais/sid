package com.damosais.sid.webapp.windows;

import java.util.Arrays;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.tepi.filtertable.FilterTable;

import com.damosais.sid.database.beans.CVEDefinition;
import com.damosais.sid.database.beans.User;
import com.damosais.sid.database.beans.UserRole;
import com.damosais.sid.database.beans.Vulnerability;
import com.damosais.sid.database.beans.VulnerabilityType;
import com.damosais.sid.database.services.CVEDefinitionService;
import com.damosais.sid.database.services.VulnerabilityService;
import com.damosais.sid.webapp.GraphicResources;
import com.damosais.sid.webapp.VulnerabilitiesView;
import com.damosais.sid.webapp.WebApplication;
import com.vaadin.data.fieldgroup.BeanFieldGroup;
import com.vaadin.data.fieldgroup.FieldGroup.CommitException;
import com.vaadin.data.util.BeanItemContainer;
import com.vaadin.data.validator.NullValidator;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Button;
import com.vaadin.ui.ComboBox;
import com.vaadin.ui.FormLayout;
import com.vaadin.ui.Notification;
import com.vaadin.ui.TextArea;
import com.vaadin.ui.TextField;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.Window;

/**
 * This class handles the window where the Vulnerabilities are created or edited
 *
 * @author Pablo Casais Solano
 * @version 1.0
 * @since 1.0
 */
@Component
public class VulnerabilityWindow extends Window {
    private static final Logger LOGGER = Logger.getLogger(VulnerabilityWindow.class);
    private static final long serialVersionUID = 6904515264886742940L;

    private final VerticalLayout content;
    
    @Autowired
    private VulnerabilityService vulnerabilityService;
    
    @Autowired
    private CVEDefinitionService cveDefinitionService;
    
    /**
     * Creates a new window to add or edit CVE definitions
     */
    public VulnerabilityWindow() {
        setModal(true);
        setSizeUndefined();
        content = new VerticalLayout();
        content.setSizeUndefined();
        content.setSpacing(true);
        content.setMargin(true);
        setContent(content);
    }
    
    /**
     * Creates the form for the CVE definition
     *
     * @param vulnerability
     *            The vulnerability to add or edit
     * @param vulnerabilitiesView
     *            The view that make the call
     * @param newItem
     *            indicates if we are creating or editing
     */
    private void createDefinitionForm(Vulnerability vulnerability, VulnerabilitiesView vulnerabilitiesView, boolean newItem) {
        // 1st) We create the form and assign the binder
        final FormLayout form = new FormLayout();
        final BeanFieldGroup<Vulnerability> binder = new BeanFieldGroup<>(Vulnerability.class);
        binder.setItemDataSource(vulnerability);
        binder.setBuffered(true);

        // 2nd) We first add the field name
        final TextField nameField = binder.buildAndBind("Name", "name", TextField.class);
        nameField.addValidator(new NullValidator("You need to provide a name", false));
        nameField.setNullRepresentation("");
        nameField.setWidth(100, Unit.PERCENTAGE);
        form.addComponent(nameField);

        // 3rd) We add the selector for the type
        final ComboBox vulnerabilityTypeField = new ComboBox("Type", Arrays.asList(VulnerabilityType.values()));
        vulnerabilityTypeField.addValidator(new NullValidator("You need to select a type", false));
        vulnerabilityTypeField.setWidth(100, Unit.PERCENTAGE);
        binder.bind(vulnerabilityTypeField, "type");
        form.addComponent(vulnerabilityTypeField);

        // 4th) We add now the table for the CVE definitions
        final FilterTable cvesTable = new FilterTable();
        cvesTable.addValidator(new NullValidator("You need to select a CVE definition", false));
        cvesTable.setFilterBarVisible(true);
        cvesTable.setContainerDataSource(new BeanItemContainer<>(CVEDefinition.class, cveDefinitionService.list()));
        // Now we define which columns are visible and what are going to be their names in the table header
        cvesTable.setVisibleColumns(new Object[] { "name", "published", "cveDesc", "severity", "cvssBaseScore" });
        cvesTable.setColumnHeaders(new String[] { "Name", "Published", "Description", "Severity", "CVSS Base Score" });
        // Finally we add the selectable behaviour
        cvesTable.setNullSelectionAllowed(false);
        cvesTable.setSelectable(true);
        cvesTable.setMultiSelect(false);
        cvesTable.setImmediate(true);
        form.addComponent(cvesTable);
        cvesTable.select(vulnerability.getDefinition());

        // 5th) We add now the text are for the notes
        final TextArea notesField = new TextArea("Notes");
        notesField.setNullRepresentation("");
        notesField.setWidth(100, Unit.PERCENTAGE);
        binder.bind(notesField, "notes");
        form.addComponent(notesField);
        
        // 6th) We now clear the window and add the components
        content.removeAllComponents();
        content.addComponent(form);

        // 7th) Now we create the save button if the user can edit data
        final User user = ((WebApplication) vulnerabilitiesView.getUI()).getUser();
        if (user.getRoles().contains(UserRole.EDIT_DATA)) {
            final Button saveButton = new Button("Save", event -> {
                try {
                    binder.commit();
                    saveVulnerability(binder.getItemDataSource().getBean(), (CVEDefinition) cvesTable.getValue(), newItem, user);
                    vulnerabilitiesView.refreshVulnerabilitiesTableContent();
                    new Notification("Success", "Vulnerability saved in the database", Notification.Type.TRAY_NOTIFICATION).show(getUI().getPage());
                    getUI().removeWindow(this);
                } catch (final CommitException e) {
                    LOGGER.error("Problem saving vulnerability in database", e);
                    Throwable cause = e;
                    while (cause.getCause() != null) {
                        cause = cause.getCause();
                    }
                    new Notification("Failure", "Error saving vulnerability: " + e.getLocalizedMessage(), Notification.Type.ERROR_MESSAGE).show(getUI().getPage());
                }
            });
            saveButton.setStyleName("link");
            saveButton.setIcon(GraphicResources.SAVE_ICON);
            content.addComponent(saveButton);
            content.setComponentAlignment(saveButton, Alignment.BOTTOM_CENTER);
        }
    }
    
    private void saveVulnerability(Vulnerability vulnerabilityCommited, CVEDefinition value, boolean newItem, User user) {
        vulnerabilityCommited.setDefinition(value);
        if (vulnerabilityCommited.getDefinition() != null) {
            vulnerabilityCommited.getDefinition().setVulnerability(vulnerabilityCommited);
        }
        if (newItem) {
            vulnerabilityCommited.setCreatedBy(user);
        } else {
            vulnerabilityCommited.setUpdatedBy(user);
        }
        vulnerabilityService.save(vulnerabilityCommited);
    }
    
    /**
     * Prepares the window to add a new vulnerability
     *
     * @param vulnerabilitiesView
     *            The view that called
     */
    public void setAddMode(VulnerabilitiesView vulnerabilitiesView) {
        setCaption("Adding new Vulnerability");
        createDefinitionForm(new Vulnerability(), vulnerabilitiesView, true);
    }

    /**
     * Prepares the window to edit an existing vulnerability
     *
     * @param vulnerabilityToAlter
     *            vulnerability to be edited
     * @param vulnerabilitiesView
     *            the view that called
     */
    public void setEditMode(Vulnerability vulnerabilityToAlter, VulnerabilitiesView vulnerabilitiesView) {
        setCaption("Editing Vulnerability");
        createDefinitionForm(vulnerabilityToAlter, vulnerabilitiesView, false);
    }
}